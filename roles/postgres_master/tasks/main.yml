---
- name: Ensure data and config directories exist
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ pg_container_uid }}"
    group: "{{ pg_container_gid }}"
    mode: "0700"
  loop:
    - "{{ pg_master_data }}"
    - "{{ pg_master_config }}"

- name: Render pg_hba.conf from template
  template:
    src: pg_hba.conf.j2
    dest: "{{ pg_master_config }}/pg_hba.conf"
    owner: "{{ pg_container_uid }}"
    group: "{{ pg_container_gid }}"
    mode: "0600"

- name: Write postgresql.conf (basic settings)
  copy:
    dest: "{{ pg_master_config }}/postgresql.conf"
    content: |
      listen_addresses = '*'
      port = {{ postgres_port }}
      wal_level = {{ wal_level }}
      max_wal_senders = {{ max_wal_senders }}
      max_replication_slots = {{ max_replication_slots }}
      wal_keep_size = 1GB
      password_encryption = md5
      ssl = off
      synchronous_standby_names = ''
      hba_file = '/etc/postgresql/pg_hba.conf'
      shared_preload_libraries = 'pg_stat_statements'
      pg_stat_statements.max = 10000
      pg_stat_statements.track = all
    owner: "{{ pg_container_uid }}"
    group: "{{ pg_container_gid }}"
    mode: "0600"

- name: Remove existing container (if any)
  community.docker.docker_container:
    name: "{{ postgres_container_name }}"
    state: absent
  ignore_errors: yes

- name: Remove old data dir (if you want a clean init) - SKIPPABLE
  file:
    path: "{{ pg_master_data }}"
    state: directory

- name: Start Postgres master container
  community.docker.docker_container:
    name: "{{ postgres_container_name }}"
    image: "{{ postgres_image }}"
    env:
      POSTGRES_USER: "{{ postgres_user }}"
      POSTGRES_PASSWORD: "{{ postgres_password }}"
      POSTGRES_DB: "{{ postgres_db }}"
    volumes:
      - "{{ pg_master_data }}:/var/lib/postgresql/data"
      - "{{ pg_master_config }}/postgresql.conf:/etc/postgresql/postgresql.conf:ro"
      - "{{ pg_master_config }}/pg_hba.conf:/etc/postgresql/pg_hba.conf:ro"
    ports:
      - "0.0.0.0:{{ postgres_port }}:5432"
    command: "postgres -c config_file=/etc/postgresql/postgresql.conf"
    restart: yes
    state: started

- name: Wait until Postgres responds (pg_isready)
  shell: |
    for i in $(seq 1 30); do
      docker exec {{ postgres_container_name }} pg_isready -U {{ postgres_user }} -d {{ postgres_db }} >/dev/null 2>&1 && exit 0
      sleep 2
    done
    exit 1
  register: pg_ready
  failed_when: pg_ready.rc != 0
  changed_when: false

- name: Ensure synchronous_standby_names is empty (avoid blocking CREATE ROLE)
  community.docker.docker_container_exec:
    container: "{{ postgres_container_name }}"
    command: >
      psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -c
      "ALTER SYSTEM SET synchronous_standby_names = '';"
  register: alter_sync
  changed_when: "'ALTER SYSTEM' in (alter_sync.stdout | default(''))"

- name: Reload Postgres config after updating pg_hba
  community.docker.docker_container_exec:
    container: "{{ postgres_container_name }}"
    command: "psql -U {{ postgres_user }} -d {{ postgres_db }} -c \"SELECT pg_reload_conf();\""
  register: reload_hba
  failed_when: reload_hba.rc != 0
  changed_when: false

- name: Wait a couple seconds after reload
  pause:
    seconds: 2

- name: Check if replication role exists
  community.docker.docker_container_exec:
    container: "{{ postgres_container_name }}"
    command: >
      psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -tAc
      "SELECT 1 FROM pg_roles WHERE rolname='{{ replication_user }}';"
  register: role_check
  changed_when: false

- name: Create replication role with retries (safe, kills conflicting CREATE ROLE)
  block:
    - name: Try to create role (single attempt)
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: >
          psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -v ON_ERROR_STOP=1 -c
          "CREATE ROLE {{ replication_user }} WITH LOGIN REPLICATION PASSWORD '{{ replication_password }}';"
      register: create_role
      failed_when: create_role.rc != 0 and "'already exists' not in (create_role.stderr | lower)"
      changed_when: create_role.rc == 0

  rescue:
    - name: Gather blocking PIDs for pg_authid (if any)
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: >
          psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -tAc
          "SELECT pid FROM pg_locks l JOIN pg_stat_activity a ON l.pid=a.pid
           WHERE relation::text LIKE 'pg_authid%' AND pid <> pg_backend_pid();"
      register: blocking_pids
      changed_when: false
      failed_when: false

    - name: Kill blocking PIDs (one by one)
      when: blocking_pids.stdout|trim != ""
      vars:
        pid_list: "{{ blocking_pids.stdout.splitlines() | map('trim') | reject('equalto','') | list }}"
      loop: "{{ pid_list }}"
      loop_control:
        loop_var: blocked_pid
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: >
          psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -c
          "SELECT pg_terminate_backend({{ blocked_pid }});"
      register: term_result
      changed_when: true
      failed_when: false

    - name: Small pause after killing blockers
      pause:
        seconds: 2

    - name: Retry create role after cleaning blockers
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: >
          psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -v ON_ERROR_STOP=1 -c
          "CREATE ROLE {{ replication_user }} WITH LOGIN REPLICATION PASSWORD '{{ replication_password }}';"
      register: create_role_retry
      failed_when: create_role_retry.rc != 0 and "'already exists' not in (create_role_retry.stderr | lower)"
      changed_when: create_role_retry.rc == 0

- name: Verify replication role exists (final check)
  community.docker.docker_container_exec:
    container: "{{ postgres_container_name }}"
    command: >
      psql -U "{{ postgres_user }}" -d "{{ postgres_db }}" -tAc
      "SELECT rolname, rolreplication FROM pg_roles WHERE rolname='{{ replication_user }}';"
  register: role_verify
  changed_when: false

- name: Fail if role not created
  fail:
    msg: "Replication role {{ replication_user }} was not created; check logs."
  when: role_verify.stdout | trim == ""

- name: Show success
  debug:
    msg: "Replication role {{ replication_user }} OK: {{ role_verify.stdout | trim }}"

- name: Remove conflicting postgresql.conf from data directory
  file:
    path: "{{ pg_master_data }}/postgresql.conf"
    state: absent
  ignore_errors: yes

- name: Setup pg_stat_statements
  block:
    - name: Wait for PostgreSQL to be ready
      shell: |
        for i in {1..30}; do
          docker exec {{ postgres_container_name }} pg_isready -U {{ postgres_user }} && exit 0
          sleep 2
        done
        exit 1
      changed_when: false

    - name: Create pg_stat_statements extension
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: "psql -U {{ postgres_user }} -d {{ postgres_db }} -c 'CREATE EXTENSION IF NOT EXISTS pg_stat_statements;'"
      register: create_ext
      changed_when: "'CREATE EXTENSION' in create_ext.stdout"

    - name: Verify pg_stat_statements is working
      community.docker.docker_container_exec:
        container: "{{ postgres_container_name }}"
        command: "psql -U {{ postgres_user }} -d {{ postgres_db }} -tAc 'SELECT count(*) FROM pg_stat_statements;'"
      register: check_ext
      changed_when: false
      failed_when: check_ext.rc != 0

    - debug:
        msg: "pg_stat_statements is working. Found {{ check_ext.stdout }} queries"
  rescue:
    - debug:
        msg: "Failed to setup pg_stat_statements: {{ create_ext.stderr | default('unknown') }}"
      failed_when: true